
name: Build SEAL Binaries

on:
  schedule:
    # Run every 6 hours to check for new SEAL releases
    - cron: '0 */6 * * *'
  workflow_dispatch:
    # Manual trigger for testing and emergency builds

env:
  asset_name: "seal"

permissions: write-all

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version_check.outputs.version }}
      tag_name: ${{ steps.version_check.outputs.tag_name }}
      upload_url: ${{ steps.release_vars.outputs.upload_url }}
      should_build: ${{ steps.version_check.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check SEAL version and existing releases
        id: version_check
        uses: actions/github-script@v7
        with:
          script: |
            // Get latest SEAL version using our script
            const { execSync } = require('child_process');
            const version = execSync('./scripts/get-latest-seal-version.sh').toString().trim();
            const tag_name = `${{ env.asset_name }}-v${version}`;

            console.log(`Latest SEAL version: ${version}`);
            console.log(`Tag name: ${tag_name}`);

            core.setOutput("version", version);
            core.setOutput("tag_name", tag_name);

            // Check if we already have this release
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });

              const existingRelease = releases.find(release => release.tag_name === tag_name);
              if (existingRelease && existingRelease.assets.length >= 3) {
                console.log(`Release ${tag_name} already exists with all assets - skipping build`);
                core.setOutput("should_build", "false");
                return;
              }
            } catch (error) {
              console.log(`No existing releases found or error checking: ${error.message}`);
            }

            console.log(`Will build ${tag_name}`);
            core.setOutput("should_build", "true");

      - name: Ensure tag exists
        if: steps.version_check.outputs.should_build == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const tag_name = "${{ steps.version_check.outputs.tag_name }}";

            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag_name}`,
              });
              console.log(`Tag [${tag_name}] already exists.`);
            } catch (error) {
              if (error.status === 404) {
                const commitResponse = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/main',
                });

                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/tags/${tag_name}`,
                  sha: commitResponse.data.sha,
                });
                console.log(`Tag [${tag_name}] created successfully.`);
              } else {
                core.setFailed(`Failed to getRef for tag [${tag_name}]. ${error}`);
              }
            }

      - name: Ensure Release exists and init release_vars
        if: steps.version_check.outputs.should_build == 'true'
        id: release_vars
        uses: actions/github-script@v7
        with:
          script: |
            const tag_name = "${{ steps.version_check.outputs.tag_name }}";
            let upload_url;

            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              const release = releases.find(release => release.tag_name === tag_name);

              if (release) {
                console.log(`Release already exists for [${tag_name}]`);
                upload_url = release.upload_url;
              } else {
                const response = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tag_name,
                  name: tag_name,
                  draft: true,
                  prerelease: false,
                });
                console.log(`Release created with tag [${tag_name}]`);
                upload_url = response.data.upload_url;
              }
            } catch (error) {
              core.setFailed(`Error while listing or creating releases: ${error.message}`);
              return;
            }

            core.setOutput("upload_url", upload_url);

  build-assets:
    needs: prepare-release
    if: needs.prepare-release.outputs.should_build == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, macos-13]
        include:
          - os: ubuntu-latest
            asset-name-suffix: ubuntu-x86_64
          - os: macos-latest
            asset-name-suffix: macos-arm64
          - os: macos-13
            asset-name-suffix: macos-x86_64
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Init asset_vars
        id: asset_vars
        uses: actions/github-script@v7
        with:
          script: |
            const tag_name = "${{ needs.prepare-release.outputs.tag_name }}";
            const asset_name = `${tag_name}-${{ matrix.asset-name-suffix }}.tgz`;
            core.setOutput("asset_name", asset_name);

            // Check if asset already exists
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              const release = releases.data.find(release => release.tag_name === tag_name);

              if (release && release.assets.some(asset => asset.name === asset_name)) {
                console.log(`No build needed for [${asset_name}]`);
                core.setOutput("do_build", "false");
              } else {
                console.log(`Build needed for [${asset_name}]`);
                core.setOutput("do_build", "true");
              }
            } catch (error) {
              console.log(`Build needed for [${asset_name}] (error checking: ${error.message})`);
              core.setOutput("do_build", "true");
            }

      - name: Install Rust Toolchain
        if: steps.asset_vars.outputs.do_build == 'true'
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          cache: "false"
          target: ${{ runner.os == 'Linux' && 'x86_64-unknown-linux-musl' || '' }}

      - name: Install System Dependencies (Ubuntu)
        if: steps.asset_vars.outputs.do_build == 'true' && runner.os == 'Linux'
        run: |
          sudo apt update
          sudo apt-get install curl cmake gcc libssl-dev pkg-config libclang-dev libpq-dev build-essential musl musl-tools musl-dev

      - name: Install System Dependencies (macOS)
        if: steps.asset_vars.outputs.do_build == 'true' && runner.os == 'macOS'
        run: |
          # Only install curl if not already present
          if ! command -v curl &>/dev/null; then
            brew install curl
          fi
          # Handle cmake with tap conflict resolution
          if ! command -v cmake &>/dev/null; then
            brew install cmake
          else
            echo "cmake already installed, checking for tap conflicts"
            if brew reinstall cmake 2>/dev/null; then
              echo "cmake reinstalled successfully"
            else
              echo "cmake reinstall failed, trying uninstall/install approach"
              brew uninstall cmake
              brew install cmake
            fi
          fi

      - name: Build SEAL binaries
        if: steps.asset_vars.outputs.do_build == 'true'
        run: |
          # Set version for the build script
          export SEAL_VERSION="${{ needs.prepare-release.outputs.version }}"

          # Run our build script
          ./scripts/build-seal.sh

          # Verify the asset was created
          asset_name="${{ steps.asset_vars.outputs.asset_name }}"
          if [ ! -f "$asset_name" ]; then
            echo "Asset not built: $asset_name"
            exit 1
          fi
          echo "Asset built: $asset_name"

      - name: Upload Asset to Release
        if: steps.asset_vars.outputs.do_build == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const asset_name = "${{ steps.asset_vars.outputs.asset_name }}";
            const upload_url = "${{ needs.prepare-release.outputs.upload_url }}";
            const version = "${{ needs.prepare-release.outputs.version }}";

            const assetPath = path.join(process.cwd(), asset_name);

            if (!fs.existsSync(assetPath)) {
              core.setFailed(`Asset file not found: ${assetPath}`);
              return;
            }

            const contentType = 'application/gzip';
            const contentLength = fs.statSync(assetPath).size;

            const headers = {
              'content-type': contentType,
              'content-length': contentLength,
            };

            const uploadAssetResponse = await github.rest.repos.uploadReleaseAsset({
              url: upload_url,
              headers,
              name: asset_name,
              data: fs.readFileSync(assetPath),
            });

            if (uploadAssetResponse.status !== 201) {
              core.setFailed(`Failed to upload ${asset_name}: ${uploadAssetResponse.status}`);
              return;
            }

            console.log(`Uploaded ${asset_name} successfully.`);
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  verify-and-publish-release:
    needs: [prepare-release, build-assets]
    if: needs.prepare-release.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Change Draft to Release when all assets present
        uses: actions/github-script@v7
        with:
          script: |
            const tag_name = "${{ needs.prepare-release.outputs.tag_name }}";
            const expectedAssets = [
              `${tag_name}-ubuntu-x86_64.tgz`,
              `${tag_name}-macos-x86_64.tgz`,
              `${tag_name}-macos-arm64.tgz`
            ];

            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const release = releases.find(release => release.tag_name === tag_name);
            if (!release) {
              core.setFailed(`Release [${tag_name}] not found`);
              return;
            }

            const asset_names = release.assets.map(asset => asset.name);
            const allAssetsPresent = expectedAssets.every(expectedAsset => asset_names.includes(expectedAsset));

            if (allAssetsPresent) {
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                draft: false,
              });
              console.log(`Release ${tag_name} published successfully with all assets`);
            } else {
              core.setFailed(`Not all expected assets are present for ${tag_name}. Expected: ${expectedAssets.join(', ')}, Found: ${asset_names.join(', ')}`);
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}